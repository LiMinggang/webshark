diff --git a/epan/column.c b/epan/column.c
index 6d4fa62..0fe3b3f 100644
--- a/epan/column.c
+++ b/epan/column.c
@@ -807,23 +807,18 @@ get_column_tooltip(const gint col)
     return g_string_free (column_tooltip, FALSE);
 }
 
+WS_DLL_PUBLIC void col_finalize(column_info *cinfo);
+
 void
-build_column_format_array(column_info *cinfo, const gint num_cols, const gboolean reset_fences)
+col_finalize(column_info *cinfo)
 {
   int i;
   col_item_t* col_item;
 
-  /* Build the column format array */
-  col_setup(cinfo, num_cols);
-
   for (i = 0; i < cinfo->num_cols; i++) {
     col_item = &cinfo->columns[i];
-    col_item->col_fmt = get_column_format(i);
-    col_item->col_title = g_strdup(get_column_title(i));
 
     if (col_item->col_fmt == COL_CUSTOM) {
-      col_item->col_custom_fields = g_strdup(get_column_custom_fields(i));
-      col_item->col_custom_occurrence = get_column_custom_occurrence(i);
       if(!dfilter_compile(col_item->col_custom_fields, &col_item->col_custom_dfilter, NULL)) {
         /* XXX: Should we issue a warning? */
         g_free(col_item->col_custom_fields);
@@ -863,9 +858,6 @@ build_column_format_array(column_info *cinfo, const gint num_cols, const gboolea
     else
       col_item->col_buf = (gchar *) g_malloc(sizeof(gchar) * COL_MAX_LEN);
 
-    if(reset_fences)
-      col_item->col_fence = 0;
-
     cinfo->col_expr.col_expr[i] = "";
     cinfo->col_expr.col_expr_val[i] = (gchar *) g_malloc(sizeof(gchar) * COL_MAX_LEN);
   }
@@ -888,6 +880,31 @@ build_column_format_array(column_info *cinfo, const gint num_cols, const gboolea
   }
 }
 
+void
+build_column_format_array(column_info *cinfo, const gint num_cols, const gboolean reset_fences)
+{
+  int i;
+  col_item_t* col_item;
+
+  /* Build the column format array */
+  col_setup(cinfo, num_cols);
+
+  for (i = 0; i < cinfo->num_cols; i++) {
+    col_item = &cinfo->columns[i];
+    col_item->col_fmt = get_column_format(i);
+    col_item->col_title = g_strdup(get_column_title(i));
+    if (col_item->col_fmt == COL_CUSTOM) {
+      col_item->col_custom_fields = g_strdup(get_column_custom_fields(i));
+      col_item->col_custom_occurrence = get_column_custom_occurrence(i);
+    }
+
+    if(reset_fences)
+      col_item->col_fence = 0;
+  }
+
+  col_finalize(cinfo);
+}
+
 /*
  * Editor modelines  -  http://www.wireshark.org/tools/modelines.html
  *
diff --git a/epan/dissectors/packet-tcp.c b/epan/dissectors/packet-tcp.c
index 3b412f4..941349d 100644
--- a/epan/dissectors/packet-tcp.c
+++ b/epan/dissectors/packet-tcp.c
@@ -713,13 +713,27 @@ static const char* tcp_host_get_filter_type(hostlist_talker_t* host, conv_filter
         return CONV_FILTER_INVALID;
     }
 
-    if (filter == CONV_FT_SRC_ADDRESS || filter == CONV_FT_DST_ADDRESS || filter == CONV_FT_ANY_ADDRESS) {
+    if (filter == CONV_FT_SRC_ADDRESS) {
         if (host->myaddress.type == AT_IPv4)
             return "ip.src";
         if (host->myaddress.type == AT_IPv6)
             return "ipv6.src";
     }
 
+    if (filter == CONV_FT_DST_ADDRESS) {
+        if (host->myaddress.type == AT_IPv4)
+            return "ip.dst";
+        if (host->myaddress.type == AT_IPv6)
+            return "ipv6.dst";
+    }
+
+    if (filter == CONV_FT_ANY_ADDRESS) {
+        if (host->myaddress.type == AT_IPv4)
+            return "ip.addr";
+        if (host->myaddress.type == AT_IPv6)
+            return "ipv6.addr";
+    }
+
     return CONV_FILTER_INVALID;
 }
 
diff --git a/ui/tap-sequence-analysis.c b/ui/tap-sequence-analysis.c
index eda3b04..4dc7282 100644
--- a/ui/tap-sequence-analysis.c
+++ b/ui/tap-sequence-analysis.c
@@ -291,7 +291,7 @@ sequence_analysis_list_get(capture_file *cf, seq_analysis_info_t *sainfo)
         return;
     }
 
-    cf_retap_packets(cf);
+    /* cf_retap_packets(cf); */
     remove_tap_listener(sainfo);
 
     /* SEQ_ANALYSIS_DEBUG("%d items", g_queue_get_length(sainfo->items)); */
@@ -514,7 +514,7 @@ sequence_analysis_dump_to_file(const char *pathname, seq_analysis_info_t *sainfo
 
     of = ws_fopen(pathname, "w");
     if (of==NULL) {
-        open_failure_alert_box(pathname, errno, TRUE);
+        /* open_failure_alert_box(pathname, errno, TRUE); */
         return FALSE;
     }
 
diff --git a/ui/voip_calls.c b/ui/voip_calls.c
index 6cd70d7..f54c6aa 100644
--- a/ui/voip_calls.c
+++ b/ui/voip_calls.c
@@ -65,8 +65,10 @@
 #include "ui/ui_util.h"
 #include "ui/voip_calls.h"
 
-#define DUMP_PTR1(p) printf("#=> %p\n",(void *)p)
-#define DUMP_PTR2(p) printf("==> %p\n",(void *)p)
+#define DUMP_PTR1(p) fprintf(stderr, "#=> %p\n",(void *)p)
+#define DUMP_PTR2(p) fprintf(stderr, "==> %p\n",(void *)p)
+
+#define simple_dialog(...)
 
 const char *voip_call_state_name[8]={
     "",
diff --git a/epan/uat-int.h b/epan/uat-int.h
index be8ecbc..364c9e4 100644
--- a/epan/uat-int.h
+++ b/epan/uat-int.h
@@ -135,6 +135,9 @@ gboolean uat_save(uat_t *uat, char **error);
  */
 void uat_load_all(void);
 
+WS_DLL_PUBLIC
+char *uat_strfld(void *rec, uat_field_t *f);
+
 /**
  * Exposes the array of valid records to the UAT consumer (dissectors), updating
  * the contents of 'data_ptr' and 'num_items_ptr' (see 'uat_new').
diff --git a/epan/uat.c b/epan/uat.c
index 461dee6..bdd570d 100644
--- a/epan/uat.c
+++ b/epan/uat.c
@@ -264,6 +264,43 @@ uat_t* uat_get_table_by_name(const char* name) {
     return NULL;
 }
 
+/* fld_tostr() from gtk/uat_gui.c */
+char *uat_strfld(void *rec, uat_field_t *f) {
+    guint        len;
+    char       *ptr;
+    char       *out;
+
+    f->cb.tostr(rec, &ptr, &len, f->cbdata.tostr, f->fld_data);
+
+    switch(f->mode) {
+        case PT_TXTMOD_NONE:
+        case PT_TXTMOD_STRING:
+        case PT_TXTMOD_ENUM:
+        case PT_TXTMOD_FILENAME:
+        case PT_TXTMOD_DIRECTORYNAME:
+            out = g_strndup(ptr, len);
+            break;
+        case PT_TXTMOD_HEXBYTES: {
+            GString *s = g_string_sized_new( len*2 + 1 );
+            guint i;
+
+            for (i=0; i<len;i++) g_string_append_printf(s, "%.2X", ((const guint8*)ptr)[i]);
+
+            out = g_strdup(s->str);
+
+            g_string_free(s, TRUE);
+            break;
+        }
+        default:
+            g_assert_not_reached();
+            out = NULL;
+            break;
+    }
+
+    g_free(ptr);
+    return out;
+}
+
 static void putfld(FILE* fp, void* rec, uat_field_t* f) {
     guint fld_len;
     char* fld_ptr;
