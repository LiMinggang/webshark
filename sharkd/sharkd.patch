diff --git a/Makefile.am b/Makefile.am
index 67ba8cd..a409f52 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -47,7 +47,7 @@ bin_PROGRAMS = \
 	@rawshark_bin@		\
 	@echld_test_bin@
 
-EXTRA_PROGRAMS = wireshark-gtk wireshark tshark tfshark capinfos captype \
+EXTRA_PROGRAMS = wireshark-gtk wireshark tshark sharkd tfshark capinfos captype \
 	editcap mergecap dftest randpkt text2pcap dumpcap reordercap \
 	rawshark echld_test
 
@@ -531,6 +531,40 @@ tshark_LDADD = \
 	@LIBGNUTLS_LIBS@		\
 	@LIBSMI_LDFLAGS@
 
+sharkd_SOURCES = \
+	$(SHARK_COMMON_SRC)	\
+	capture_opts.c		\
+	filter_files.c		\
+	sharkd.c		\
+	sharkd_daemon.c		\
+	sharkd_session.c	\
+	ws_version_info.c
+
+sharkd_CPPFLAGS = $(AM_CPPFLAGS) $(GLIB_CFLAGS)
+
+sharkd_LDFLAGS = $(AM_LDFLAGS) $(EXTRALINKFLAGS)
+
+# Libraries and plugin flags with which to link tshark.
+sharkd_LDADD = \
+	capchild/libcapchild.a		\
+	caputils/libcaputils.a		\
+	ui/cli/libcliui.a		\
+	ui/libui.a			\
+	wiretap/libwiretap.la		\
+	epan/libwireshark.la		\
+	wsutil/libwsutil.la		\
+	@SSL_LIBS@			\
+	$(plugin_ldadd)			\
+	@GLIB_LIBS@			\
+	@PCAP_LIBS@			\
+	@C_ARES_LIBS@			\
+	@KRB5_LIBS@			\
+	@SYSTEMCONFIGURATION_FRAMEWORKS@	\
+	@COREFOUNDATION_FRAMEWORKS@	\
+	@LIBGCRYPT_LIBS@		\
+	@LIBGNUTLS_LIBS@		\
+	@LIBSMI_LDFLAGS@
+
 tfshark_SOURCES = \
 	$(SHARK_COMMON_SRC)	\
 	tfshark.c		\
diff --git a/epan/column.c b/epan/column.c
index 1f7b2fa..4ca1fa1 100644
--- a/epan/column.c
+++ b/epan/column.c
@@ -807,23 +807,18 @@ get_column_tooltip(const gint col)
     return g_string_free (column_tooltip, FALSE);
 }
 
+WS_DLL_PUBLIC void col_finalize(column_info *cinfo);
+
 void
-build_column_format_array(column_info *cinfo, const gint num_cols, const gboolean reset_fences)
+col_finalize(column_info *cinfo)
 {
   int i;
   col_item_t* col_item;
 
-  /* Build the column format array */
-  col_setup(cinfo, num_cols);
-
   for (i = 0; i < cinfo->num_cols; i++) {
     col_item = &cinfo->columns[i];
-    col_item->col_fmt = get_column_format(i);
-    col_item->col_title = g_strdup(get_column_title(i));
 
     if (col_item->col_fmt == COL_CUSTOM) {
-      col_item->col_custom_fields = g_strdup(get_column_custom_fields(i));
-      col_item->col_custom_occurrence = get_column_custom_occurrence(i);
       if(!dfilter_compile(col_item->col_custom_fields, &col_item->col_custom_dfilter, NULL)) {
         /* XXX: Should we issue a warning? */
         g_free(col_item->col_custom_fields);
@@ -863,9 +858,6 @@ build_column_format_array(column_info *cinfo, const gint num_cols, const gboolea
     else
       col_item->col_buf = (gchar *) g_malloc(sizeof(gchar) * COL_MAX_LEN);
 
-    if(reset_fences)
-      col_item->col_fence = 0;
-
     cinfo->col_expr.col_expr[i] = "";
     cinfo->col_expr.col_expr_val[i] = (gchar *) g_malloc(sizeof(gchar) * COL_MAX_LEN);
   }
@@ -888,6 +880,31 @@ build_column_format_array(column_info *cinfo, const gint num_cols, const gboolea
   }
 }
 
+void
+build_column_format_array(column_info *cinfo, const gint num_cols, const gboolean reset_fences)
+{
+  int i;
+  col_item_t* col_item;
+
+  /* Build the column format array */
+  col_setup(cinfo, num_cols);
+
+  for (i = 0; i < cinfo->num_cols; i++) {
+    col_item = &cinfo->columns[i];
+    col_item->col_fmt = get_column_format(i);
+    col_item->col_title = g_strdup(get_column_title(i));
+    if (col_item->col_fmt == COL_CUSTOM) {
+      col_item->col_custom_fields = g_strdup(get_column_custom_fields(i));
+      col_item->col_custom_occurrence = get_column_custom_occurrence(i);
+    }
+
+    if(reset_fences)
+      col_item->col_fence = 0;
+  }
+
+  col_finalize(cinfo);
+}
+
 /*
  * Editor modelines  -  http://www.wireshark.org/tools/modelines.html
  *
diff --git a/epan/dissectors/packet-tcp.c b/epan/dissectors/packet-tcp.c
index bc7f4fd..856936e 100644
--- a/epan/dissectors/packet-tcp.c
+++ b/epan/dissectors/packet-tcp.c
@@ -709,13 +709,27 @@ static const char* tcp_host_get_filter_type(hostlist_talker_t* host, conv_filter
         return CONV_FILTER_INVALID;
     }
 
-    if (filter == CONV_FT_SRC_ADDRESS || filter == CONV_FT_DST_ADDRESS || filter == CONV_FT_ANY_ADDRESS) {
+    if (filter == CONV_FT_SRC_ADDRESS) {
         if (host->myaddress.type == AT_IPv4)
             return "ip.src";
-        if (host->myaddress.type == AT_IPv6)
+        if (host->myaddress.type == AT_IPv6)
             return "ipv6.src";
     }
 
+    if (filter == CONV_FT_DST_ADDRESS) {
+        if (host->myaddress.type == AT_IPv4)
+            return "ip.dst";
+        if (host->myaddress.type == AT_IPv6)
+            return "ipv6.dst";
+    }
+
+    if (filter == CONV_FT_ANY_ADDRESS) {
+        if (host->myaddress.type == AT_IPv4)
+            return "ip.addr";
+        if (host->myaddress.type == AT_IPv6)
+            return "ipv6.addr";
+    }
+
     return CONV_FILTER_INVALID;
 }
 
diff --git a/wsutil/jsmn.h b/wsutil/jsmn.h
index 7cf51aa..a0622d8 100644
--- a/wsutil/jsmn.h
+++ b/wsutil/jsmn.h
@@ -91,7 +91,7 @@ WS_DLL_PUBLIC void jsmn_init(jsmn_parser *parser);
  * Run JSON parser. It parses a JSON data string into and array of tokens, each describing
  * a single JSON object.
  */
-int jsmn_parse(jsmn_parser *parser, const char *js, size_t len,
+WS_DLL_PUBLIC int jsmn_parse(jsmn_parser *parser, const char *js, size_t len,
 		jsmntok_t *tokens, unsigned int num_tokens);
 
 /**
diff --git a/ui/tap-sequence-analysis.c b/ui/tap-sequence-analysis.c
index 48cd9fd..6edc0d1 100644
--- a/ui/tap-sequence-analysis.c
+++ b/ui/tap-sequence-analysis.c
@@ -290,7 +290,7 @@ sequence_analysis_list_get(capture_file *cf, seq_analysis_info_t *sainfo)
         return;
     }
 
-    cf_retap_packets(cf);
+    /* cf_retap_packets(cf); */
     remove_tap_listener(sainfo);
 
     /* SEQ_ANALYSIS_DEBUG("%d items", g_queue_get_length(sainfo->items)); */
@@ -505,7 +505,7 @@ sequence_analysis_dump_to_file(const char *pathname, seq_analysis_info_t *sainfo
 
     of = ws_fopen(pathname, "w");
     if (of==NULL) {
-        open_failure_alert_box(pathname, errno, TRUE);
+        /* open_failure_alert_box(pathname, errno, TRUE); */
         return FALSE;
     }
 
diff --git a/ui/voip_calls.c b/ui/voip_calls.c
index 609ead9..301624c 100644
--- a/ui/voip_calls.c
+++ b/ui/voip_calls.c
@@ -65,8 +65,10 @@
 #include "ui/ui_util.h"
 #include "ui/voip_calls.h"
 
-#define DUMP_PTR1(p) printf("#=> %p\n",(void *)p)
-#define DUMP_PTR2(p) printf("==> %p\n",(void *)p)
+#define DUMP_PTR1(p) fprintf(stderr, "#=> %p\n",(void *)p)
+#define DUMP_PTR2(p) fprintf(stderr, "==> %p\n",(void *)p)
+
+#define simple_dialog(...)
 
 const char *voip_call_state_name[8]={
     "",
diff --git a/epan/uat-int.h b/epan/uat-int.h
index 46a32bc..a9b26bd 100644
--- a/epan/uat-int.h
+++ b/epan/uat-int.h
@@ -103,6 +103,9 @@ gboolean uat_save(uat_t* , char** );
 
 void uat_load_all(void);
 
+WS_DLL_PUBLIC
+char *uat_strfld(void *rec, uat_field_t *f);
+
 #define UAT_UPDATE(uat) do { *((uat)->user_ptr) = (void*)((uat)->user_data->data); *((uat)->nrows_p) = (uat)->user_data->len; } while(0)
 #define UAT_INDEX_PTR(uat,idx) (uat->raw_data->data + (uat->record_size * (idx)))
 #define UAT_USER_INDEX_PTR(uat,idx) (uat->user_data->data + (uat->record_size * (idx)))
diff --git a/epan/uat.c b/epan/uat.c
index 084c3f8..fdbc83e 100644
--- a/epan/uat.c
+++ b/epan/uat.c
@@ -248,6 +248,43 @@ uat_t* uat_get_table_by_name(const char* name) {
     return NULL;
 }
 
+/* fld_tostr() from gtk/uat_gui.c */
+char *uat_strfld(void *rec, uat_field_t *f) {
+    guint        len;
+    char       *ptr;
+    char       *out;
+
+    f->cb.tostr(rec, &ptr, &len, f->cbdata.tostr, f->fld_data);
+
+    switch(f->mode) {
+        case PT_TXTMOD_NONE:
+        case PT_TXTMOD_STRING:
+        case PT_TXTMOD_ENUM:
+        case PT_TXTMOD_FILENAME:
+        case PT_TXTMOD_DIRECTORYNAME:
+            out = g_strndup(ptr, len);
+            break;
+        case PT_TXTMOD_HEXBYTES: {
+            GString *s = g_string_sized_new( len*2 + 1 );
+            guint i;
+
+            for (i=0; i<len;i++) g_string_append_printf(s, "%.2X", ((const guint8*)ptr)[i]);
+
+            out = g_strdup(s->str);
+
+            g_string_free(s, TRUE);
+            break;
+        }
+        default:
+            g_assert_not_reached();
+            out = NULL;
+            break;
+    }
+
+    g_free(ptr);
+    return out;
+}
+
 static void putfld(FILE* fp, void* rec, uat_field_t* f) {
     guint fld_len;
     char* fld_ptr;
