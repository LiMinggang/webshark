diff --git a/epan/column.c b/epan/column.c
index 6d4fa62..0fe3b3f 100644
--- a/epan/column.c
+++ b/epan/column.c
@@ -807,23 +807,18 @@ get_column_tooltip(const gint col)
     return g_string_free (column_tooltip, FALSE);
 }
 
+WS_DLL_PUBLIC void col_finalize(column_info *cinfo);
+
 void
-build_column_format_array(column_info *cinfo, const gint num_cols, const gboolean reset_fences)
+col_finalize(column_info *cinfo)
 {
   int i;
   col_item_t* col_item;
 
-  /* Build the column format array */
-  col_setup(cinfo, num_cols);
-
   for (i = 0; i < cinfo->num_cols; i++) {
     col_item = &cinfo->columns[i];
-    col_item->col_fmt = get_column_format(i);
-    col_item->col_title = g_strdup(get_column_title(i));
 
     if (col_item->col_fmt == COL_CUSTOM) {
-      col_item->col_custom_fields = g_strdup(get_column_custom_fields(i));
-      col_item->col_custom_occurrence = get_column_custom_occurrence(i);
       if(!dfilter_compile(col_item->col_custom_fields, &col_item->col_custom_dfilter, NULL)) {
         /* XXX: Should we issue a warning? */
         g_free(col_item->col_custom_fields);
@@ -863,9 +858,6 @@ build_column_format_array(column_info *cinfo, const gint num_cols, const gboolea
     else
       col_item->col_buf = (gchar *) g_malloc(sizeof(gchar) * COL_MAX_LEN);
 
-    if(reset_fences)
-      col_item->col_fence = 0;
-
     cinfo->col_expr.col_expr[i] = "";
     cinfo->col_expr.col_expr_val[i] = (gchar *) g_malloc(sizeof(gchar) * COL_MAX_LEN);
   }
@@ -888,6 +880,31 @@ build_column_format_array(column_info *cinfo, const gint num_cols, const gboolea
   }
 }
 
+void
+build_column_format_array(column_info *cinfo, const gint num_cols, const gboolean reset_fences)
+{
+  int i;
+  col_item_t* col_item;
+
+  /* Build the column format array */
+  col_setup(cinfo, num_cols);
+
+  for (i = 0; i < cinfo->num_cols; i++) {
+    col_item = &cinfo->columns[i];
+    col_item->col_fmt = get_column_format(i);
+    col_item->col_title = g_strdup(get_column_title(i));
+    if (col_item->col_fmt == COL_CUSTOM) {
+      col_item->col_custom_fields = g_strdup(get_column_custom_fields(i));
+      col_item->col_custom_occurrence = get_column_custom_occurrence(i);
+    }
+
+    if(reset_fences)
+      col_item->col_fence = 0;
+  }
+
+  col_finalize(cinfo);
+}
+
 /*
  * Editor modelines  -  http://www.wireshark.org/tools/modelines.html
  *
diff --git a/ui/tap-sequence-analysis.c b/ui/tap-sequence-analysis.c
index eda3b04..4dc7282 100644
--- a/ui/tap-sequence-analysis.c
+++ b/ui/tap-sequence-analysis.c
@@ -77,7 +77,7 @@ void sequence_analysis_info_free(seq_analysis_info_t *sainfo)
 /****************************************************************************/
 /* whenever a frame packet is seen by the tap listener */
 /* Add a new frame into the graph */
-static gboolean
+gboolean
 seq_analysis_frame_packet( void *ptr, packet_info *pinfo, epan_dissect_t *edt _U_, const void *dummy _U_)
 {
     seq_analysis_info_t *sainfo = (seq_analysis_info_t *) ptr;
@@ -190,7 +190,7 @@ seq_analysis_frame_packet( void *ptr, packet_info *pinfo, epan_dissect_t *edt _U
 /****************************************************************************/
 /* whenever a TCP packet is seen by the tap listener */
 /* Add a new tcp frame into the graph */
-static gboolean
+gboolean
 seq_analysis_tcp_packet( void *ptr, packet_info *pinfo, epan_dissect_t *edt _U_, const void *tcp_info)
 {
     seq_analysis_info_t *sainfo = (seq_analysis_info_t *) ptr;
@@ -291,7 +291,7 @@ sequence_analysis_list_get(capture_file *cf, seq_analysis_info_t *sainfo)
         return;
     }
 
-    cf_retap_packets(cf);
+    /* cf_retap_packets(cf); */
     remove_tap_listener(sainfo);
 
     /* SEQ_ANALYSIS_DEBUG("%d items", g_queue_get_length(sainfo->items)); */
@@ -514,7 +514,7 @@ sequence_analysis_dump_to_file(const char *pathname, seq_analysis_info_t *sainfo
 
     of = ws_fopen(pathname, "w");
     if (of==NULL) {
-        open_failure_alert_box(pathname, errno, TRUE);
+        /* open_failure_alert_box(pathname, errno, TRUE); */
         return FALSE;
     }
 
diff --git a/ui/tap-sequence-analysis.h b/ui/tap-sequence-analysis.h
index 39b0983..51ff40f 100644
--- a/ui/tap-sequence-analysis.h
+++ b/ui/tap-sequence-analysis.h
@@ -91,6 +91,10 @@ typedef struct _seq_analysis_info {
 #define SEQ_ANALYSIS_DEBUG()
 #endif
 
+gboolean seq_analysis_frame_packet(void *, packet_info *, epan_dissect_t *, const void *);
+
+gboolean seq_analysis_tcp_packet(void *, packet_info *, epan_dissect_t *, const void *);
+
 /** Create and initialize a seq_analysis_info_t struct
  * @return A pointer to a newly allocated seq_analysis_info_t struct.
  */
diff --git a/ui/voip_calls.c b/ui/voip_calls.c
index 6cd70d7..f54c6aa 100644
--- a/ui/voip_calls.c
+++ b/ui/voip_calls.c
@@ -65,8 +65,10 @@
 #include "ui/ui_util.h"
 #include "ui/voip_calls.h"
 
-#define DUMP_PTR1(p) printf("#=> %p\n",(void *)p)
-#define DUMP_PTR2(p) printf("==> %p\n",(void *)p)
+#define DUMP_PTR1(p) fprintf(stderr, "#=> %p\n",(void *)p)
+#define DUMP_PTR2(p) fprintf(stderr, "==> %p\n",(void *)p)
+
+#define simple_dialog(...)
 
 const char *voip_call_state_name[8]={
     "",
diff --git a/epan/uat-int.h b/epan/uat-int.h
index 2624779..5be9e8b 100644
--- a/epan/uat-int.h
+++ b/epan/uat-int.h
@@ -130,6 +130,9 @@ gboolean uat_save(uat_t *uat, char **error);
  */
 void uat_load_all(void);
 
+WS_DLL_PUBLIC
+char *uat_strfld(void *rec, uat_field_t *f);
+
 /**
  * Exposes the array of valid records to the UAT consumer (dissectors), updating
  * the contents of 'data_ptr' and 'num_items_ptr' (see 'uat_new').
diff --git a/epan/uat.c b/epan/uat.c
index 92fac8f..1867eee 100644
--- a/epan/uat.c
+++ b/epan/uat.c
@@ -262,6 +262,43 @@ uat_t* uat_get_table_by_name(const char* name) {
     return NULL;
 }
 
+/* fld_tostr() from gtk/uat_gui.c */
+char *uat_strfld(void *rec, uat_field_t *f) {
+    guint        len;
+    char       *ptr;
+    char       *out;
+
+    f->cb.tostr(rec, &ptr, &len, f->cbdata.tostr, f->fld_data);
+
+    switch(f->mode) {
+        case PT_TXTMOD_NONE:
+        case PT_TXTMOD_STRING:
+        case PT_TXTMOD_ENUM:
+        case PT_TXTMOD_FILENAME:
+        case PT_TXTMOD_DIRECTORYNAME:
+            out = g_strndup(ptr, len);
+            break;
+        case PT_TXTMOD_HEXBYTES: {
+            GString *s = g_string_sized_new( len*2 + 1 );
+            guint i;
+
+            for (i=0; i<len;i++) g_string_append_printf(s, "%.2X", ((const guint8*)ptr)[i]);
+
+            out = g_strdup(s->str);
+
+            g_string_free(s, TRUE);
+            break;
+        }
+        default:
+            g_assert_not_reached();
+            out = NULL;
+            break;
+    }
+
+    g_free(ptr);
+    return out;
+}
+
 static void putfld(FILE* fp, void* rec, uat_field_t* f) {
     guint fld_len;
     char* fld_ptr;
diff --git a/epan/stat_tap_ui.c b/epan/stat_tap_ui.c
index 4f7895b..e6338d3 100644
--- a/epan/stat_tap_ui.c
+++ b/epan/stat_tap_ui.c
@@ -155,6 +155,11 @@ void register_stat_tap_table_ui(stat_tap_table_ui *ui)
     wmem_tree_insert_string(registered_stat_tables, ui->cli_string, ui, 0);
 }
 
+stat_tap_table_ui *new_stat_tap_by_name(const char *name)
+{
+    return (stat_tap_table_ui *) wmem_tree_lookup_string(registered_stat_tables, name, 0);
+}
+
 void new_stat_tap_iterate_tables(wmem_foreach_func func, gpointer user_data)
 {
     wmem_tree_foreach(registered_stat_tables, func, user_data);
diff --git a/epan/stat_tap_ui.h b/epan/stat_tap_ui.h
index b30c089..39220df 100644
--- a/epan/stat_tap_ui.h
+++ b/epan/stat_tap_ui.h
@@ -181,6 +181,8 @@ WS_DLL_PUBLIC stat_tap_table_item_type* new_stat_tap_get_field_data(const stat_t
 WS_DLL_PUBLIC void new_stat_tap_set_field_data(stat_tap_table *stat_table, guint table_index, guint field_index, stat_tap_table_item_type* field_data);
 WS_DLL_PUBLIC void reset_stat_table(stat_tap_table_ui* new_stat, new_stat_tap_gui_reset_cb gui_callback, void *callback_data);
 
+WS_DLL_PUBLIC stat_tap_table_ui *new_stat_tap_by_name(const char *name);
+
 /** Free all of the tables associated with a stat_tap_table_ui.
  *
  * Frees data created by stat_tap_ui.stat_tap_init_cb.
